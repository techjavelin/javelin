import { ref } from 'vue'
import { generateClient } from 'aws-amplify/data'
import type { Schema } from '../../amplify/data/resource'
import { withAuth } from '../amplifyClient'
import { normalizeError } from './useError'

const client = generateClient<Schema>()

export function useVulnerabilityFindings() {
  const findings = ref<Schema['VulnerabilityFinding']['type'][]>([])
  const currentFinding = ref<Schema['VulnerabilityFinding']['type'] | null>(null)
  const loading = ref(false)
  const error = ref<string>('')

  async function list(params: { engagementId?: string; applicationId?: string; severity?: string; status?: string; limit?: number; nextToken?: string } = {}) {
    loading.value = true
    error.value = ''
    try {
      const filter: any = {}
      if (params.engagementId) filter.engagementId = { eq: params.engagementId }
      if (params.applicationId) filter.applicationId = { eq: params.applicationId }
      if (params.severity) filter.severity = { eq: params.severity }
      if (params.status) filter.status = { eq: params.status }
      const res = await client.models.VulnerabilityFinding.list(withAuth({ filter: Object.keys(filter).length ? filter : undefined, limit: params.limit, nextToken: params.nextToken }))
      findings.value = res.data || []
      return { nextToken: res.nextToken }
    } catch (e:any) {
      error.value = normalizeError(e,'Failed to load findings').message
      return { nextToken: undefined }
    } finally {
      loading.value = false
    }
  }

  async function get(id: string) {
    loading.value = true
    error.value = ''
    try {
      const res = await client.models.VulnerabilityFinding.get(withAuth({ id }))
      currentFinding.value = res.data ?? null
      return currentFinding.value
    } catch (e:any) {
      error.value = normalizeError(e,'Failed to load finding').message
      return null
    } finally {
      loading.value = false
    }
  }

  async function create(input: Partial<Schema['VulnerabilityFinding']['type']>) {
    try {
      const res = await client.models.VulnerabilityFinding.create(withAuth({
        engagementId: input.engagementId!,
        applicationId: input.applicationId!,
        title: input.title!,
        severity: (input.severity as any) || 'MEDIUM',
        status: (input.status as any) || 'OPEN',
        templateId: input.templateId,
        description: input.description || '',
        impact: input.impact || '',
        reproduction: input.reproduction || '',
        remediation: input.remediation || '',
        references: input.references || [],
        affectedAssets: input.affectedAssets || [],
        evidence: input.evidence || [],
        cvssVector: input.cvssVector || '',
        cvssScore: input.cvssScore ?? null,
        reportedAt: input.reportedAt || new Date().toISOString(),
        publicationStatus: (input as any).publicationStatus || 'DRAFT',
        createdBy: input.createdBy || undefined
      }))
      if (res.data) findings.value.push(res.data)
      return res.data
    } catch (e:any) {
      error.value = normalizeError(e,'Failed to create finding').message
      return null
    }
  }

  async function update(id: string, patch: Partial<Schema['VulnerabilityFinding']['type']>) {
    try {
      const res = await client.models.VulnerabilityFinding.update(withAuth({ id, ...patch }))
      if (res.data) {
        const idx = findings.value.findIndex(f => f.id === id)
        if (idx >= 0) findings.value[idx] = res.data
      }
      return res.data
    } catch (e:any) {
      error.value = normalizeError(e,'Failed to update finding').message
      return null
    }
  }

  async function remove(id: string) {
    try {
      await client.models.VulnerabilityFinding.delete(withAuth({ id }))
      findings.value = findings.value.filter(f => f.id !== id)
    } catch (e:any) {
      error.value = normalizeError(e,'Failed to delete finding').message
    }
  }

  return { findings, currentFinding, loading, error, list, get, create, update, remove }
}
